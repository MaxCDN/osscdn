(function(global) {

/*     Configuration constants - generated by `configure`   */

var VERSION='1.0.0';
var OBJECT_NAME='HydnaChannel';
var COMET_PATH='/comet/';
var FLASH_PATH='//cdnjs.cloudflare.com/ajax/libs/hydna/1.0.0/bridge.swf';
var DISABLE_WEBSOCKET=false;
var DISABLE_FLASH=false;
var DISABLE_COMET=false;

/*
  These constants MUST be provided by the builder:
    - OBJECT_NAME (string)
    - DISABLE_WEBSOCKET (boolean)
    - DISABLE_FLASH (boolean)
    - DISABLE_COMET (boolean)
    - COMET_PATH (string)
    - FLASH_PATH (string)
    - VERSION (string)
*/

var PAYLOAD_MAX_SIZE = 0xfffa;
var BFRAME_MAX_SIZE = 0xffff;
var UFRAME_MAX_SIZE = 0x15554;

var PAYLOAD_TYPE_TEXT = 0;
var PAYLOAD_TYPE_BINARY = 1;

var OP_HEARTBEAT = 0x0;
var OP_OPEN = 0x1;
var OP_DATA = 0x2;
var OP_SIGNAL = 0x3;
var OP_RESOLVE = 0x4;

// Channel modes
var READ = 0x01;
var WRITE = 0x02;
var READWRITE = 0x03;
var EMIT = 0x04;

// flags
var FLAG_ALLOW = 0x0;
var FLAG_EMIT = 0x0;
var FLAG_END = 0x1;
var FLAG_DENY = 0x7;
var FLAG_ERROR = 0x7;

var ALL_CHANNELS = 0;

var MODE_RE = /^(r|read){0,1}(w|write){0,1}(?:\+){0,1}(e|emit){0,1}$/i;


// Range 1000-1999 is compatible with WebSocket specification.
var STATUS_NORMAL_CLOSURE = 1000;
var STATUS_GOING_AWAY = 1001;
var STATUS_PROTOCOL_ERROR = 1002;
var STATUS_UNSUPPORTED_DATA = 1003;
var STATUS_NO_STATUS_RCVD = 1005;
var STATUS_ABNORMAL_CLOSURE = 1006;
var STATUS_INVALID_PAYLOAD = 1007;
var STATUS_POLICY_VIOLATION = 1008;
var STATUS_MESSAGE_TOO_BIG = 1009;
var STATUS_MANDATORY_EXT = 1010;
var STATUS_INTERNAL_SERVER_ERROR = 1011;
var STATUS_TLS_HANDSHAKE = 1015;

// Range 5000-5999 is hydna specific
var STATUS_OPEN_DENIED = 5000;
var STATUS_SIGNAL = 5001;
var STATUS_CHANNEL_OPEN = 5002;
var STATUS_TRANSPORT_FAILURE = 5003;

// Map native types to local scope, if exists
var encodeURIComponent = global.encodeURIComponent;
var decodeURIComponent = global.decodeURIComponent;
var escape = global.escape;
var unescape = global.unescape;

// Check if the browser supports ArrayBuffers's. If not,
// use Arrays instead.
var ArrayBuffer = global.ArrayBuffer;
var atobin = null;

if (ArrayBuffer == undefined) {
  ArrayBuffer = function() {};
  atobin = atoarr;
} else {
  atobin = atoab;
}

var createFrame = null;

var uniqueId = (function () {
  var incr = 1;
  return function (asString) {
    var id = incr++;
    if (!asString) {
      return id;
    }
    id = incr.toString(16);
    while (id.length < 8) id = 0 + id;
    return id;
  };
}());


var time = Date.now || (function () {
  return (new Date()).getTime();
});

var EXPORTS = (function () {
  switch (true) {
    case typeof module !== "undefined" &&
         typeof module.exports !== "undefined":
    return "common";
    case typeof define === "function" && !!define.amd:
    return "amd";
  }
  return "global";  
}());
/*
 * Copyright (c) 2010 Nick Galbreath
 * http://code.google.com/p/stringencoders/source/browse/#svn/trunk/javascript
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
*/

/* base64 encode/decode compatible with window.btoa/atob
 *
 * window.atob/btoa is a Firefox extension to convert binary data (the "b")
 * to base64 (ascii, the "a").
 *
 * It is also found in Safari and Chrome.  It is not available in IE.
 *
 * if (!window.btoa) window.btoa = base64.encode
 * if (!window.atob) window.atob = base64.decode
 *
 * The original spec's for atob/btoa are a bit lacking
 * https://developer.mozilla.org/en/DOM/window.atob
 * https://developer.mozilla.org/en/DOM/window.btoa
 *
 * window.btoa and base64.encode takes a string where charCodeAt is [0,255]
 * If any character is not [0,255], then an exception is thrown.
 *
 * window.atob and base64.decode take a base64-encoded string
 * If the input length is not a multiple of 4, or contains invalid characters
 *   then an exception is thrown.
 */
var base64 = {};
base64.PADCHAR = '=';
base64.ALPHA = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
base64.getbyte64 = function(s,i) {
    // This is oddly fast, except on Chrome/V8.
    //  Minimal or no improvement in performance by using a
    //   object with properties mapping chars to value (eg. 'A': 0)
    var idx = base64.ALPHA.indexOf(s.charAt(i));
    if (idx == -1) {
        throw "Cannot decode base64";
    }
    return idx;
}

base64.decode = function(s) {
    // convert to string
    s = "" + s;
    var getbyte64 = base64.getbyte64;
    var pads, i, b10;
    var imax = s.length
    if (imax == 0) {
        return s;
    }

    if (imax % 4 != 0) {
        throw "Cannot decode base64";
    }

    pads = 0
    if (s.charAt(imax -1) == base64.PADCHAR) {
        pads = 1;
        if (s.charAt(imax -2) == base64.PADCHAR) {
            pads = 2;
        }
        // either way, we want to ignore this last block
        imax -= 4;
    }

    var x = [];
    for (i = 0; i < imax; i += 4) {
        b10 = (getbyte64(s,i) << 18) | (getbyte64(s,i+1) << 12) |
            (getbyte64(s,i+2) << 6) | getbyte64(s,i+3);
        x.push(String.fromCharCode(b10 >> 16, (b10 >> 8) & 0xff, b10 & 0xff));
    }

    switch (pads) {
    case 1:
        b10 = (getbyte64(s,i) << 18) | (getbyte64(s,i+1) << 12) | (getbyte64(s,i+2) << 6)
        x.push(String.fromCharCode(b10 >> 16, (b10 >> 8) & 0xff));
        break;
    case 2:
        b10 = (getbyte64(s,i) << 18) | (getbyte64(s,i+1) << 12);
        x.push(String.fromCharCode(b10 >> 16));
        break;
    }
    return x.join('');
}

base64.getbyte = function(s,i) {
    var x = s.charCodeAt(i);
    if (x > 255) {
        throw "INVALID_CHARACTER_ERR: DOM Exception 5";
    }
    return x;
}


base64.encode = function(s) {
    if (arguments.length != 1) {
        throw "SyntaxError: Not enough arguments";
    }
    var padchar = base64.PADCHAR;
    var alpha   = base64.ALPHA;
    var getbyte = base64.getbyte;

    var i, b10;
    var x = [];

    // convert to string
    s = "" + s;

    var imax = s.length - s.length % 3;

    if (s.length == 0) {
        return s;
    }
    for (i = 0; i < imax; i += 3) {
        b10 = (getbyte(s,i) << 16) | (getbyte(s,i+1) << 8) | getbyte(s,i+2);
        x.push(alpha.charAt(b10 >> 18));
        x.push(alpha.charAt((b10 >> 12) & 0x3F));
        x.push(alpha.charAt((b10 >> 6) & 0x3f));
        x.push(alpha.charAt(b10 & 0x3f));
    }
    switch (s.length - imax) {
    case 1:
        b10 = getbyte(s,i) << 16;
        x.push(alpha.charAt(b10 >> 18) + alpha.charAt((b10 >> 12) & 0x3F) +
               padchar + padchar);
        break;
    case 2:
        b10 = (getbyte(s,i) << 16) | (getbyte(s,i+1) << 8);
        x.push(alpha.charAt(b10 >> 18) + alpha.charAt((b10 >> 12) & 0x3F) +
               alpha.charAt((b10 >> 6) & 0x3f) + padchar);
        break;
    }
    return x.join('');
}

// Use base64 lib if not natively supported
var btoa = global.btoa || base64.encode;
var atob = global.atob || base64.decode;
var nextTick = null;
if (typeof setImmediate != "undefined") {
  nextTick = setImmediate;
} else if (typeof postMessage != "undefined" && typeof window != "undefined") {
	nextTick = (function() {
	  var TOKEN = "nextTick." + ((Math.random() * 0xFFFF) & 0xFFFF).toString();
    var callbacks = [];
    var incr = 1;

  	function message(event) {
  	  var C;
  		if (event.source == global && event.data === TOKEN) {
  		  (C = callbacks.shift()) && C();
  		}
  	}

  	if (global.addEventListener) {
  		global.addEventListener("message", message, false);
  	} else if (global.attachEvent) {
  		global.attachEvent("onmessage", message);
  	} else {
  	  global.onmessage = message;
  	}

	  return function(C) {
	    callbacks.push(C);
	    global.postMessage(TOKEN, "*");
	    return incr++;
	  }
	})();
} else {
  nextTick = function(C) { setTimeout(C, 0); };
}
// parserUri
// Based on Steve Levithan's parseUri
// (c) Steven Levithan <stevenlevithan.com>
// MIT License
var parseUri = (function() {
  var PARSE_RE = /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
  var KEYS = ["source","protocol","authority","userInfo","user","password","host","port","relative","path","directory","file","query","anchor"];

  return function(str) {
  	var m = PARSE_RE.exec(str);
    var uri = {};
  	var i = 14;
  	var authority;

  	while (i--) m[i] && (uri[KEYS[i]] = m[i]);

    if ((authority = uri.authority) && (i = authority.indexOf("@")) !== -1) {
      uri.authority = authority.substr(i + 1);
    }

    uri.path = uri.path || '/';

  	return uri;
  };
})();

var FLAG_BITMASK = 0x7;

var OP_BITPOS = 3;
var OP_BITMASK = (0x7 << OP_BITPOS);

var CTYPE_BITPOS = 6;
var CTYPE_BITMASK = (0x1 << CTYPE_BITPOS);


// Converts an ArrayBuffer to UTF8
function abtoutf(ab, offset) {
	var result = [];

  for (var i = offset, l = ab.byteLength; i < l; i++) {
		result.push(String.fromCharCode(ab[i]));
  }

	return decodeURIComponent(escape(result.join("")));
}


// Converts a base64-string to an array with number.
function atoarr(a) {
  var arr = [];
  for (var i = 0, l = a.length; i < l; i++) {
    arr[i] = a.charCodeAt(i);
  }
  return arr;
}


// Converts a string to a ArrayBuffer
function atoab(a) {
  var ab;
  ab = new Uint8Array(a.length);
  for (var i = 0, l = a.length; i < l; i++) {
    ab[i] = a.charCodeAt(i);
  }
  return ab.buffer;
}


// Create a binary frame
function createFrameBin(ptr, op, flag, data) {
  var poff = 0;
  var plen = 0;
  var chars;
  var payload;
  var view;
  var frame;
  var ctype;
  var b;

  ctype = PAYLOAD_TYPE_TEXT;

  if (data) {
    if (typeof data == "string") {
      chars = unescape(encodeURIComponent(data));
      view = new Uint8Array(chars.length);
    	for (var i = 0, l = chars.length; i < l; i++) {
    		view[i] = chars.charCodeAt(i);
      }
      payload = view.buffer;
      plen = payload.byteLength;
    } else if (data instanceof ArrayBuffer) {
      ctype = PAYLOAD_TYPE_BINARY;
      payload = data;
      plen = data.byteLength;
    } else if (data.buffer instanceof ArrayBuffer) {
      ctype = PAYLOAD_TYPE_BINARY;
      payload = data.buffer;
      poff = data.byteOffset;
      plen = data.byteLength;
    } else if (data.length) {
      ctype = PAYLOAD_TYPE_BINARY;
      view = new Uint8Array(data.length);
      for (var i = 0, l = data.length; i < l; i++) {
        view[i] = parseInt(data[i]);
      }
      payload = view.buffer;
      plen = this.data.byteLength;
    } else {
      throw new Error("UNSUPPORTED_TYPE_ERR");
    }
  }

  if (5 + plen > BFRAME_MAX_SIZE) {
    throw new Error("FRAME_OVERFLOW_ERR");
  }

  frame = new ArrayBuffer(5 + plen);

  view = new Uint8Array(frame)
  view[0] = ptr >>> 24 & 0xff;
  view[1] = ptr >>> 16 & 0xff;
  view[2] = ptr >>> 8 & 0xff;
  view[3] = ptr % 256;
  view[4] = (ctype << CTYPE_BITPOS) | (op << OP_BITPOS) | flag;

  if (plen) {
    view.set(new Uint8Array(payload, poff, plen), 5);
  }

  return frame;
}

// Creates an UTF frame
function createFrameUtf(ptr, op, flag, data) {
  var buffer;
  var frame;
  var view;
  var payload;
  var result;
  var ctype;

  ctype = PAYLOAD_TYPE_TEXT;

  if (data) {
    if (typeof data == "string") {
      payload = unescape(encodeURIComponent(data));
    } else if (data instanceof ArrayBuffer ||
               data.buffer instanceof ArrayBuffer) {
      ctype = PAYLOAD_TYPE_BINARY;
      buffer = data.buffer || data;
      view = new Uint8Array(buffer, data.byteOffset || 0, data.byteLength);
      payload = [];
      for (var i = 0, l = view.byteLength; i < l; i++) {
        payload[i] = String.fromCharCode(view[i]);
      }
    } else if (data.length) {
      ctype = PAYLOAD_TYPE_BINARY;
      payload = [];
      for (var i = 0, l = data.length; i < l; i++) {
        b = (parseInt(data[i]) % 256 + 256) % 256;
        payload[i] = String.fromCharCode(b);
      }
    } else {
      throw new Error("UNSUPPORTED_TYPE_ERR");
    }
  }

  frame = new Array();
  frame[0] = String.fromCharCode((ptr >>> 24) & 0xff);
  frame[1] = String.fromCharCode((ptr >>> 16) & 0xff);
  frame[2] = String.fromCharCode((ptr >>> 8) & 0xff);
  frame[3] = String.fromCharCode(ptr & 0xff);
  frame[4] = String.fromCharCode((ctype << CTYPE_BITPOS) |
                                 (op << OP_BITPOS) |
                                  flag);

  if (payload) {
    frame = frame.concat(payload);
  }

  result = btoa(frame.join(""));

  if (result.length > UFRAME_MAX_SIZE) {
    throw new Error("FRAME_OVERFLOW_ERR");
  }

  return result;
}


function getsize(data) {
  if (typeof data == "string") {
    return unescape(encodeURIComponent(data)).length;
  } else if (data instanceof ArrayBuffer ||
             data.buffer instanceof ArrayBuffer) {
    return data.byteLength
  } else if (data.length) {
    return data.length;
  } else {
    throw new Error("UNSUPPORTED_TYPE_ERR");
  }
}


// Binary message parser
function sockMessageBinImpl(event) {
  var ptr;
  var ctype;
  var op;
  var flag;
  var data;
  var payload;
  var tmp;

  if ((data = event.data) instanceof ArrayBuffer === false) {
    return this.close(null, STATUS_PROTOCOL_ERROR, "ERR_UNSUPPORTED_TYPE");
  }

  if (event.data.byteLength < 5) {
    return this.close(null, STATUS_PROTOCOL_ERROR, "ERR_BAD_HEADER_SIZE");
  }

  data = new Uint8Array(event.data);

  ptr = (data[1] << 16 |
         data[2] << 8 |
         data[3]) + (data[0] << 24 >>> 0);

  desc = data[4];

  ctype = (desc & CTYPE_BITMASK) >> CTYPE_BITPOS;
  op = (desc & OP_BITMASK) >> OP_BITPOS;
  flag = (desc & FLAG_BITMASK);

  if (data.byteLength > 5) {
    try {
      if (ctype == PAYLOAD_TYPE_TEXT) {
        payload = abtoutf(data, 5);
      } else {
        tmp = new Uint8Array(data.length - 5);
        tmp.set(data.subarray(5));
        payload = tmp.buffer;
      }
    } catch (err) {
      return this.close(null, STATUS_PROTOCOL_ERROR, "ENCODING_ERR");
    }
  }

  if (this.onframe) {
    this.onframe(ptr, op, flag, payload);
  }
}


// Utf message parser implementation
function sockMessageUtfImpl(event) {
  var data = event.data;
  var ptr;
  var op;
  var flag;
  var ctype;
  var payload;
  var desc;

  if (!data || !data.length) {
    return this.close(null, STATUS_PROTOCOL_ERROR, "ERR_UNSUPPORTED_TYPE");
  }

  if (data.length < 8) {
    return this.close(null, STATUS_PROTOCOL_ERROR, "BAD_HEADER_SIZE_ERR");
  }

  try {
    data = atob(data);
  } catch (err) {
    return this.close(null, STATUS_PROTOCOL_ERROR, "ENCODING_ERR");
  }

  ptr = (data.charCodeAt(1) << 16 |
         data.charCodeAt(2) << 8 |
         data.charCodeAt(3)) + (data.charCodeAt(0) << 24 >>> 0);

  desc = data.charCodeAt(4);

  ctype = (desc & CTYPE_BITMASK) >> CTYPE_BITPOS;
  op = (desc & OP_BITMASK) >> OP_BITPOS;
  flag = (desc & FLAG_BITMASK);

  if (data.length > 5) {
    try {
      if (ctype == PAYLOAD_TYPE_TEXT) {
        payload = decodeURIComponent(escape(data.substr(5)));
      } else {
        // TODO: Convert to ArrayBuffer if possible
        payload = atobin(data.substr(5));
      }
    } catch (err) {
      return this.close(null, STATUS_PROTOCOL_ERROR, "ENCODING_ERR");
    }
  }

  if (this.onframe) {
    this.onframe(ptr, op, flag, payload);
  }
}


// Returns the binary representation of a mode expression. Returns null
// on invalid mode.
function getBinMode(modeExpr) {
  var result = 0;
  var match;

  if (!modeExpr) {
    return 0;
  }

  if (typeof modeExpr !== "string" || !(match = modeExpr.match(MODE_RE))) {
    return null;
  }

  match[1] && (result |= READ);
  match[2] && (result |= WRITE);
  match[3] && (result |= EMIT);

  return result;
}


function cloneData(data) {
  var clone;
  var buffer;

  if (!data || typeof data == "string") {
    return data;
  }

  if (typeof data.slice == 'function') {
    return data.slice(0);
  }

  buffer = new Uint8Array(data);
  clone = new Uint8Array(buffer.length);

  for (var i = 0, l = buffer.length; i < l; i++) {
    clone[i] = buffer[i];
  }

  return clone;
}
function OpenEvent(target, data) {
  this.target = target;
  this.data = data;
}

OpenEvent.prototype.type = "open";


function MessageEvent(target, flag, data) {
  this.target = target;
  this.priority = flag;
  this.data = data;
}

MessageEvent.prototype.type = "message";


function SignalEvent(target, data) {
  this.target = target;
  this.data = data;
}

SignalEvent.prototype.type = "signal";


function ErrorEvent(target, data) {
  this.target = target;
  this.data = data;
  this.message = data;
  if (typeof data == "string") {
    this.message = data;
  } else {
    this.message = "UNKNOWN_ERR";
  }
}

ErrorEvent.prototype.type = "error";



function CloseEvent(target, code, reason, hadError) {
  this.target = target;

  this.wasClean = code == STATUS_NORMAL_CLOSURE;
  this.wasDenied = code == STATUS_OPEN_DENIED;
  this.hadError = !this.wasClean && !this.wasDenied;

  this.code = code;
  this.reason = reason || "";
  this.data = reason;

}

CloseEvent.prototype.type = "close";


function addEventHandler(target, event, handler) {
  if (typeof event !== "string") {
    throw new Error("Expected `event` as String");
  }
  if (typeof handler !== "function") {
    throw new Error("Expected `handler` as Function");
  }
  if (!target._events[event]) {
    target._events[event] = handler;
  } else if (typeof target._events[event] !== 'function') {
    target._events[event].push(handler);
  } else {
    target._events[event] = [target._events[event], handler];
  }
}


function removeEventHandler(target, type, handler) {
  var idx;
  var handlers;
  if (!type || !handler) {
    return;
  }
  if (!(handlers = target._events[type])) {
    return;
  } else if (typeof handlers === 'function') {
    if (handlers == handler) {
      delete target._events[type];
    }
  } else {
    idx = handlers.length;
    while (idx--) {
      if (handlers[idx] == handler) {
        handlers.splice(idx, 1);
        if (handlers.length == 1) {
          target._events[type] = handlers[0];
        }
        break;
      }
    }
  }
}


function callEventHandler(target, event, handler) {
  try {
    handler.call(target, event);
  } catch (dispatchError) {
    nextTick(function () {
      throw dispatchError;
    });
  }
}


function dispatchEvent(event) {
  var type;
  var handler;
  var target;

  if (!event ||
      typeof (type = event.type) !== 'string' ||
      !(target = event.target)) {
    return;
  }

  if ((handler = target['on' + type])) {
    callEventHandler(target, event, handler);
  }

  if ((handler = target._events[event.type])) {

    if (typeof handler !== "function") {
      for (var i = 0, l = handler.length; i < l; i++) {
        callEventHandler(target, event, handler[i]);
      }
    } else {
      callEventHandler(target, event, handler);
    }
  }
}

var AVAILABLE_TRANSPORTS = {};
var DEFAULT_TRANSPORT = null;
var availableConnections = {};

function getConnection(channel, urlobj, options) {
  var transport;
  var connection;
  var connections;
  var connkey;
  var connurl;
  var path;

  var allowTransportFallback;

  if (options && options.transport !== "auto") {
    transport = options.transport;
    allowTransportFallback = false;
  } else if ("__FORCE_TRANSPORT_SOCKET__" in global){
    transport = global.__FORCE_TRANSPORT_SOCKET__;
    allowTransportFallback = false;
  } else {
    if (DEFAULT_TRANSPORT == null) {
      throw new Error("Browser does not support any of the transport protocols");
    }
    transport = DEFAULT_TRANSPORT;
    if (options && options.allowTransportFallback) {
      allowTransportFallback = options.allowTransportFallback;
    } else {
      allowTransportFallback = true;
    }
  }

  if (transport in AVAILABLE_TRANSPORTS == false) {
    throw new Error("Bad transport '" + transport + "'");
  }

  connurl = connectionUrl(urlobj);
  connkey = connectionKey(connurl, transport);
  path = urlobj.path;

  if ((connections = availableConnections[connkey])) {
    for (var i = 0; i < connections.length; i++) {
      if (path in connections[i].channels == false) {
        connection = connections[i];
        break;
      }
    }
  }

  if (!connection) {
    connection = new Connection(connurl, transport, allowTransportFallback);
    if (transport in availableConnections == false) {
      availableConnections[connkey] = [];
    }
    availableConnections[connkey].push(connection);
  }

  connection.createChannel(channel, urlobj.path);

  return connection;
}


function connectionKey(connurl, transport) {
  return [transport, connurl].join(':');
}


function connectionUrl(urlobj) {
  var result;
  var protocol;

  result = [urlobj.protocol, '://', urlobj.host];

  if (urlobj.port) {
    result.push(':' + urlobj.port);
  }

  return result.join('');
}


function Connection(url, transport, allowTransportFallback) {
  this.url = url;
  this.transport = transport;
  this.refcount = 0;
  this.channels = {};
  this.routes = {};
  this.socket = null;
  this.connecting = false;
  this.connected = false;

  this.keepAliveTimer = null;
  this.lastSentMessage = 0;

  this.allowTransportFallback = allowTransportFallback;

  this.bindTransport();
}


Connection.prototype.bindTransport = function() {
  var self = this;
  var initTransport;
  var socket;

  initTransport = AVAILABLE_TRANSPORTS[self.transport];
  socket = initTransport(self.url);

  socket.onopen = function() {
    var channels = self.channels;
    self.connected = true;
    self.connecting = false;
    for (var path in channels) {
      self.send(0, OP_RESOLVE, 0, path);
    }
    self.startKeepAliveTimer();
  };

  socket.onframe = function(ptr, op, flag, data) {
    switch (op) {
      case OP_HEARTBEAT: return;
      case OP_OPEN: return self.processOpen(ptr, flag, data);
      case OP_DATA: return self.processData(ptr, flag, data);
      case OP_SIGNAL: return self.processSignal(ptr, flag, data);
      case OP_RESOLVE: return self.processResolve(ptr, flag, data);
    }
  };

  socket.onerror = function(err) {

    self.socket = null;

    this.onopen = null;
    this.onclose = null;
    this.onerror = null;
    this.onframe = null;

    self.destroy(err);
  };

  socket.onclose = function(event) {
    var reason;
    var code;

    self.socket = null;

    this.onopen = null;
    this.onclose = null;
    this.onerror = null;
    this.onframe = null;

    if (event) {
      code = event.code || STATUS_NORMAL_CLOSURE;

      if (code != STATUS_NORMAL_CLOSURE) {
        reason = event.message || event.reason || "Connection reset by server";
      }
    } else {
      code = event.code || STATUS_ABNORMAL_CLOSURE;
      reason = "Connection reset by server";
    }

    if (code == STATUS_TRANSPORT_FAILURE &&
        self.connecting == true &&
        self.allowTransportFallback == true &&
        "fallbackTransport" in this &&
        this.fallbackTransport in AVAILABLE_TRANSPORTS) {
      // Try with a fallback socket if available
      self.transport = this.fallbackTransport;
      self.bindTransport();
      return;
    }

    self.destroy(null, code, reason);
  };

  socket._destroyed = false;

  socket.destroy = function(err, code, reason) {
    if (this._destroyed) {
      return;
    }
    this._destroyed = true;
    if (err && this.onerror) {
      this.onerror(err);
    }

    if (code && this.onclose) {
      this.onclose(null, code, reason);
    }

    this.close();
  };

  this.socket = socket;
  this.connecting = true;
};


Connection.prototype.createChannel = function(channel, path) {
  var channels = this.channels
  var socket = this.socket;
  var channel;

  if (path in channels) {
    throw new Error("Channel already created");
  }

  channels[path] = channel;
  this.refcount++;

  // Do not send request if socket isnt handshaked yet
  if (this.connected) {
    this.send(0, OP_RESOLVE, 0, path);
  }
};


Connection.prototype.destroyChannel = function(channel, err, code, data) {
  var channels = this.channels
  var routes = this.routes;

  if (typeof channel._path !== 'string') {
    return;
  }

  delete channels[channel._path];

  if (typeof channel._ptr == 'number') {
    delete routes[channel._ptr];
  }

  channel._onend(err, code, data);

  if (--this.refcount == 0) {
    this.destroy();
  }
};


Connection.prototype.send = function(ptr, op, flag, data) {
  var frame;
  if (this.socket && this.connected) {
    this.lastSentMessage = (new Date()).getTime();
    frame = this.socket.createFrame(ptr, op, flag, data);
    return this.socket.send(frame);
  } else {
    return false;
  }
};


Connection.prototype.startKeepAliveTimer = function () {
  var self = this;
  this.keepAliveTimer = setInterval(function () {
    var now = (new Date()).getTime();

    if (now - self.lastSentMessage >= 15000) {
      self.send(0, OP_HEARTBEAT, 0);
    }
  }, 5000);
};


Connection.prototype.processOpen = function(ptr, flag, data) {
  var channel;

  if (!(channel = this.routes[ptr])) {
    this.destroy(null, STATUS_PROTOCOL_ERROR, "UNKNOWN_OPEN_RESP_ERR");
    return;
  }

  if (channel.readyState !== Channel.CONNECTING) {
    this.destroy(null, STATUS_PROTOCOL_ERROR, "CHANNEL_NOT_CONNECTING_ERR");
  }

  if (flag == FLAG_ALLOW) {
    channel._onopen(data);
  } else {
    this.destroyChannel(channel, null, STATUS_OPEN_DENIED, data);
  }
};


Connection.prototype.processData = function(ptr, flag, data) {
  var routes = this.routes;
  var channel;

  if (ptr === ALL_CHANNELS) {
    for (var chanptr in routes) {
      channel = routes[chanptr];
      if (channel.readyState == Channel.OPEN && channel.readable) {
        dispatchEvent(new MessageEvent(channel, flag, cloneData(data)));
      }
    }
  } else if ((channel = routes[ptr])) {
    if (channel.readyState == Channel.OPEN && channel.readable) {
      dispatchEvent(new MessageEvent(channel, flag, data));
    }
  }
};


Connection.prototype.processSignal = function(ptr, flag, data) {
  var routes = this.routes;
  var frame;
  var clone;
  var channel;
  var event;

  switch (flag) {

    case FLAG_EMIT:
      if (ptr === ALL_CHANNELS) {
        for (var chanptr in routes) {
          channel = routes[chanptr];
          if (channel.readyState == Channel.OPEN) {
            dispatchEvent(new SignalEvent(channel, cloneData(data)));
          }
        }
      } else if ((channel = routes[ptr])) {
        if (channel.readyState == Channel.OPEN) {
          dispatchEvent(new SignalEvent(channel, data));
        }
      }
      break;

    case FLAG_END:
    case FLAG_ERROR:
      if (ptr === ALL_CHANNELS) {
        if (flag == FLAG_END) {
          this.destroy(null, STATUS_NORMAL_CLOSURE, data);
        } else {
          this.destroy(null, STATUS_SIGNAL, data);
        }
        return;
      }

      if (!(channel = routes[ptr])) {
        // Protocol violation. Channel does not exists in client. Ignore
        // for now.
        return;
      }

      if (channel.readyState == Channel.CLOSING) {
        this.destroyChannel(channel, null, STATUS_NORMAL_CLOSURE);
      } else {
        this.send(ptr, OP_SIGNAL, FLAG_END);
        if (flag == FLAG_END) {
          this.destroyChannel(channel, null, STATUS_NORMAL_CLOSURE, data);
        } else {
          this.destroyChannel(channel, null, STATUS_SIGNAL, data);
        }
      }
      break;

    default:
      this.destroy(null, STATUS_PROTOCOL_ERROR, "Unknown signal flag SIGFLAG");
      return;
  }
};


Connection.prototype.processResolve = function(ptr, flag, data) {
  var channel;
  var frame;
  var path;

  if (typeof data !== "string" || data.length == 0) {
    this.destroy(null, STATUS_INVALID_PAYLOAD, "Resolve payload empty");
    return;
  }

  path = data;

  if (!(channel = this.channels[path])) {
    return;
  }

  if (channel.readyState == Channel.CLOSING) {
    this.destroyChannel(channel, null, STATUS_NORMAL_CLOSURE);
    return;
  }

  if (flag != FLAG_ALLOW) {
    this.destroyChannel(channel,
                        null,
                        STATUS_OPEN_DENIED,
                        "Unable to resolve path");
    return;
  }

  this.routes[ptr] = channel;
  channel._ptr = ptr;

  this.send(ptr, OP_OPEN, channel._mode, channel._token);
};


// Destroy connection with optional Error
Connection.prototype.destroy = function(err, code, data) {
  var channels = this.channels;
  var connections;
  var connkey;
  var channel;
  var idx;

  if (!this.url) {
    return;
  }

  connkey = connectionKey(this.url, this.transport);
  connections = availableConnections[connkey];
  idx = connections && connections.length || 0;

  while (idx--) {
    if (connections[idx] == this) {
      connections.splice(idx, 1);
      if (connections.length == 0) {
        delete availableConnections[connkey];
      }
      break;
    }
  }

  this.url = null;
  this.connecting = false;
  this.connected = false;
  this.channels = {};
  this.routes = {};
  this.refcount = 0;
  this.transport = null;

  for (var path in channels) {
    if ((channel = channels[path])) {
      channel._onend(err, code, cloneData(data));
    }
  }

  if (this.keepAliveTimer) {
    clearInterval(this.keepAliveTimer);
    this.keepAliveTimer = null;
  }

  if (this.socket) {
    this.socket.onopen = null;
    this.socket.onerror = null;
    this.socket.onclose = null;
    this.socket.onframe = null;
    try {
      this.socket.close();
    } catch (err) {
    } finally {
      this.socket = null;
    }
  }
};


function bridgeOpenHandler() {
  this.connected = true;

  if (this.initTimer) {
    clearTimeout(this.initTimer);
    this.initTimer = null;
  }

  if (!this.onopen) {
    return;
  }

  this.onopen();
}


function bridgeMessageHandler(data) {
  if (!this.onmessage) {
    return;
  }

  this.onmessage({
    type: "message",
    data: data
  });
}


function bridgeErrorHandler(err) {
  this.close(STATUS_TRANSPORT_FAILURE, err || "BRIDGE_UNKNOWN_ERR");
}


function bridgeCloseHandler() {
  this.close(STATUS_ABNORMAL_CLOSURE, "BRIDGE_UNKNOWN_ERR");
}
function Channel(url, mode, options) {
  var urlobj;
  var protocol;

  if (!DEFAULT_TRANSPORT) {
    throw new Error("Not supported in current browser");
  }

  if (typeof url !== "string") {
    throw new Error("bad argument, `url`, expected String");
  }

  if (/^http:\/\/|^https:\/\//.test(url) == false) {
    protocol = /^http/.test(location.protocol) ? location.protocol : 'http:';
    url = protocol + "//" + url;
  }

  urlobj = parseUri(url);

  if (urlobj.protocol !== "https" && urlobj.protocol !== "http") {
    throw new Error("bad protocol, expected `http` or `https`");
  }

  if (typeof (this._mode = getBinMode(mode)) !== "number") {
    throw new Error("Invalid mode");
  }

  try {
    this._connection = getConnection(this, urlobj, options);
  } catch(connectionError) {
    this._mode = 0;
    throw connectionError;
  }

  this._path = urlobj.path;
  this.url = this._connection.url + this._path;
  this.transport = this._connection.transport;

  this._token = urlobj.query || null;
  this._ptr = null;
  this._resolved = false;
  this._endsig = null;
  this._events = {};

  this.readyState = Channel.CONNECTING;

  this.readable = ((this._mode & READ) == READ);
  this.writable = ((this._mode & WRITE) == WRITE);
  this.emitable = ((this._mode & EMIT) == EMIT);
}


Channel.CONNECTING = Channel.prototype.CONNECTING = 0;
Channel.OPEN = Channel.prototype.OPEN = 1;
Channel.CLOSING = Channel.prototype.CLOSING = 2;
Channel.CLOSED = Channel.prototype.CLOSED = 3;

Channel.prototype.extensions = "";
Channel.prototype.protocol = "";
Channel.prototype.binaryType = typeof ArrayBuffer == "undefined" ? void(0)
                                                                 : "arraybuffer";

try {
  Object.defineProperty(Channel.prototype, "bufferedAmount", {
    configurable : true,
    enumerable: true,
    get: function () {
      var socket = this._connection && this._connection.socket || null;
      return  socket ? socket.bufferedAmount : 0;
    }
  });
} catch (err) {
  Channel.prototype.bufferedAmount = 0;
}

Channel.prototype._onopen = function(data) {
  this._token = null;

  if (this.readyState == Channel.CLOSING) {
    this.channel.send(OP_SIGNAL, FLAG_END, this._endsig);
    this._endsig = null;
    return;
  }

  this.readyState = Channel.OPEN;

  dispatchEvent(new OpenEvent(this, data));
};


Channel.prototype._onend = function(err, code, reason) {
  var event;
  var code;
  var message;

  if (this.readyState === Channel.CLOSED) {
    return;
  }

  this.readyState = Channel.CLOSED;

  this._ptr = null;
  this._token = null;
  this._resolved = false;
  this._mode = null;

  this._connection = null;
  this._endsig = null;

  if (err) {
    event = new ErrorEvent(this, typeof err == "string" ? err : err.message);
    dispatchEvent(event);
  }

  message = reason;

  if (!code) {
    code = STATUS_ABNORMAL_CLOSURE;
    message = "Connection to remote closed";
  }

  event = new CloseEvent(this, code,  message || null, !!(err));
  dispatchEvent(event);

  this._path = null;
  this._url = null;
};


Channel.prototype.on = function(event, handler) {
  addEventHandler(this, event, handler);
  return this;
};


Channel.prototype.off = function(event, handler) {
  removeEventHandler(this, event, handler);
  return this;
};


Channel.prototype.addEventListener = function(event, handler) {
  addEventHandler(this, event, handler);
};


Channel.prototype.removeEventListener = function(event, handler) {
  removeEventHandler(this, event, handler);
};


Channel.prototype.send = function(data, priority) {
  var flag = (arguments[1] || 0);

  if (this.readyState !== Channel.OPEN) {
    throw new Error("INVALID_STATE_ERR");
  }

  if (!this.writable) {
    throw new Error("NOT_WRITABLE_ERR");
  }

  if (flag < 0 || flag > 7 || isNaN(flag)) {
    throw new Error("Bad priority, expected Number between 0-7");
  }

  if (!data || (!data.length && !data.byteLength)) {
    throw new Error("Expected `data`");
  }

  return this._connection.send(this._ptr, OP_DATA, flag, data);
};


Channel.prototype.emit = function(data) {

  if (this.readyState !== Channel.OPEN) {
    throw new Error("INVALID_STATE_ERR");
  }

  if (!this.emitable) {
    throw new Error("NOT_EMITABLE_ERR");
  }

  if (!data || (!data.length && !data.byteLength)) {
    throw new Error("Expected `data`");
  }

  return this._connection.send(this._ptr, OP_SIGNAL, FLAG_EMIT, data);
};


Channel.prototype.close = function(data) {
  var frame;

  if (this.readyState !== Channel.CONNECTING &&
      this.readyState !== Channel.OPEN) {
    return;
  }

  if (typeof data == 'number') {
    data = arguments[1];
  }

  if (data) {
    if ((!data.length && !data.byteLength)) {
      throw new Error("Expected `data`");
    }
  }

  this.readable = false;
  this.writable = false;
  this.emitable = false;

  if (this.readyState === Channel.OPEN) {
    this._connection.send(this._ptr, OP_SIGNAL, FLAG_END, data);
  } else {
    this._endsig = data;
  }

  this.readyState = Channel.CLOSING;
};
var WebSocketTransport = {

  WebSocket: null,
  binarySupport: false,

  init: function(wsurl) {
    var WebSocket = global.WebSocket;
    var agent;
    var tmpsock;
    var m;

    if (global.MozWebSocket) {
      WebSocket = global.MozWebSocket;
    } else if ((binarySupport = ("binaryType" in WebSocket.prototype)) == false) {
      agent = navigator.userAgent;
      // Detect if we can use ArrayBuffers in transport
      switch (true) {

        case (!!(m = /Chrome\/(\d+)/.exec(agent))) && (parseInt(m[1]) >= 15):
        case (!!(m = /Firefox\/(\d+)/.exec(agent))) && (parseInt(m[1]) >= 11):
        case (!!(m = /MSIE\s(\d+)/.exec(agent))) && (parseInt(m[1]) >= 10):
        WebSocketTransport.binarySupport = true;
        break;

        default:
        try {
          tmpsock = new WebSocket(wsurl);
          WebSocketTransport.binarySupport = !!(tmpsock.binaryType);
          tmpsock.close();
        } catch (e) {
        }
        break;
      }
    }

    WebSocketTransport.WebSocket = WebSocket;
  }
};


function webSocketInit(url) {
  var urlobj;
  var wsurl;

  urlobj = parseUri(url);

  wsurl = (urlobj.protocol == 'http' ? 'ws://' : 'wss://') + urlobj.host;
  if (urlobj.port) {
    wsurl += ':' + urlobj.port;
  }

  if (!WebSocketTransport.WebSocket) {
    WebSocketTransport.init(wsurl);
  }

  try {
    socket = new WebSocketTransport.WebSocket(wsurl,
                                      ["wsutf.winkprotocol.org"].concat(
                                          WebSocketTransport.binarySupport ?
                                          ["wsbin.winkprotocol.org"] : []));
  } catch (initError) {
    return nextTick(function () {
      socket.onclose({
        code: STATUS_TRANSPORT_FAILURE,
        message: initError.message || "Failed to connect to remote"
      });
    });
  }

  if (WebSocketTransport.binarySupport) {
    socket.binaryType = "arraybuffer";
    socket.onmessage = sockMessageBinImpl;
    socket.createFrame = createFrameBin;
  } else {
    socket.onmessage = sockMessageUtfImpl;
    socket.createFrame = createFrameUtf;
  }

  if ("bufferedAmount" in socket == false) {
    socket.bufferedAmount = 0;
  }

  return socket;
}

if ((typeof DISABLE_WEBSOCKET == "undefined" || DISABLE_WEBSOCKET == false) &&
    (global.WebSocket || global.MozWebSocket)) {
  AVAILABLE_TRANSPORTS["websocket"] = webSocketInit;
  DEFAULT_TRANSPORT = "websocket";
}


function hasFlashSupport() {
  var nav = global.navigator;
  var mkey = "application/x-shockwave-flash";
  var ActiveX;
  var major;
  var plugin;

  if ((/android/i).test(nav.userAgent)) {
    return false;
  }

  if (typeof nav.plugins != "undefined" &&
      (plugin = nav.plugins["Shockwave Flash"]) &&
      plugin.description &&
      ((mime = nav.mimeTypes) && mime[mkey] && mime[mkey].enabledPlugin)) {
    major = /\s(\d+)/.exec(plugin.description);
    return major[1] && (parseInt(major[1]) > 9);
  } else if ((ActiveX = global.ActiveXObject)) {
    try {
      if ((plugin = new ActiveX("ShockwaveFlash.ShockwaveFlash"))) {
        major = /\s(\d+)/.exec(plugin.GetVariable("$version"));
        return major[1] && (parseInt(major[1]) > 9);
      }
    } catch(e) {
      return false;
    }
  }

  return false;
}


var FlashTransport = {
  sockets: {},
  ready: false,
  bridge: null,

  embed: function() {
    var body;
    var str = [];
    var vars = [];
    var objname;
    var codebase;
    var pluginpage;
    var members;
    var path;
    var bridge;
    var tmpl;
    var id;

    // Use channel as our global object if not using AMD/common-support.
    if (EXPORTS !== "global") {
      do {
        objname = '__hydnaFlashTransport' + (Math.random() * 0xFFFFFFFF);
      } while(global.document.getElementById(objname));
      window[objname] = FlashTransport;
    } else {
      objname = OBJECT_NAME + '.__bridge';
      Channel.__bridge = FlashTransport;
    }


    // Both `name` and `id` is required by internet explorer.
    do {
      id = "__" + time();
    } while(global.document.getElementById(id));

    members = { onhandshake: 1, onready: 1, onopen: 1,
                onclose: 1, onerror: 1, onmessage: 1 };

    for (var key in members) {
      vars.push(key + "=" + objname + "." + key);
    }

    codebase = "http://fpdownload.macromedia.com/pub/shockwave/cabs/"
               "flash/swflash.cab#version=9,0,0,0";

    pluginpage = "http://www.macromedia.com/go/getflashplayer";

    path = FLASH_PATH + "?" + (Math.random() * 0xFFFFFFFF);

    str[0 ] = '<object name="' + id + '" id="' + id + '"' +
              ' classid="clsid:d27cdb6e-ae6d-11cf-96b8-444553540000"' +
              ' codebase="' +  codebase + '" name=' +
              ' width="1" height="1">';
    str[1 ] = '<param name="allowScriptAccess" value="always"></param>';
    str[2 ] = '<param name="allowNetworking" value="true"></param>';
    str[3 ] = '<param name="movie" value="' + path + '"></param>';
    str[4 ] = '<param name="quality" value="low"></param>';
    str[5 ] = '<param name="menu" value="false"></param>';
    str[6 ] = '<param name="FlashVars" value="' + vars.join("&") + '">';
    str[7 ] = '</param><param name="bgcolor" value="#ffffff"></param>';
    str[8 ] = '<param name="wmode" value="transparent"></param>';
    str[9 ] = '<embed  src="' + path + '" quality="low" bgcolor="#ffffff"' +
              ' wmode="transparent" width="1" height="1"' +
              ' swLiveConnect="true" allowScriptAccess="always"' +
              ' allowNetworking="true" menu="false"' +
              ' type="application/x-shockwave-flash"' +
              ' FlashVars="' + vars.join("&") + '"' +
              ' pluginspage="' + pluginpage + '">';
    str[10] = '</object>';

    tmpl = document.createElement("div");
    tmpl.innerHTML = str.join("");
    bridge = tmpl.childNodes[0];

    if (!global.document.all) {
      for (var i = 0; i < bridge.childNodes.length; i++) {
        if (bridge.childNodes[i].nodeName.toUpperCase() == "EMBED") {
          bridge = bridge.childNodes[i];
          break;
        }
      }
    }

    bridge.style.position = "absolute";
    bridge.style.top = "0px";
    bridge.style.left = "0px";
    bridge.style.width = "1px";
    bridge.style.height = "1px";
    bridge.style.zIndex = "-100000";

    body = document.getElementsByTagName('body')[0];
    body.appendChild(bridge);

    FlashTransport.bridge = bridge;
  },

  onhandshake: function() {
    return typeof navigator !== "undefined" && navigator.userAgent || "none";
  },

  onready: function() {
    nextTick(function() {
      var sockets = FlashTransport.sockets;
      var socket;

      FlashTransport.ready = true;

      for (var id in sockets) {
        socket = FlashTransport.sockets[id];
        socket.init();
      }
    });
    return true;
  },

  onopen: function(id) {
    var socket;
    if ((socket = FlashTransport.sockets[id])) {
      socket.openHandler();
    }
  },

  onmessage: function(id, data) {
    var socket;
    if ((socket = FlashTransport.sockets[id])) {
      socket.messageHandler(data);
    }
  },

  onerror: function(id, err) {
    var socket;
    if ((socket = FlashTransport.sockets[id])) {
      socket.errorHandler(err);
    }
  },

  onclose: function(id) {
    var socket;
    if ((socket = FlashTransport.sockets[id])) {
      socket.closeHandler();
    }
  }
};


function FlashSocket(url) {
  var self = this;

  this.id = uniqueId();
  this.url = url;
  this.connected = false;

  this.initTimer = setTimeout(function () {
    self.errorHandler("FLASH_INIT_TIMEOUT_ERR");
  }, 15000);
}

FlashSocket.prototype.bufferedAmount = 0;

FlashSocket.prototype.fallbackTransport = "comet";

FlashSocket.prototype.onmessage = sockMessageUtfImpl;
FlashSocket.prototype.createFrame = createFrameUtf;
FlashSocket.prototype.openHandler = bridgeOpenHandler;
FlashSocket.prototype.closeHandler = bridgeCloseHandler;
FlashSocket.prototype.errorHandler = bridgeErrorHandler;
FlashSocket.prototype.messageHandler = bridgeMessageHandler;


FlashSocket.prototype.init = function () {
  var urlobj = parseUri(this.url);
  var url = urlobj.protocol + "://" + urlobj.host;
  if (urlobj.port) {
    url += ':' + urlobj.port;
  }

  if (urlobj.protocol == 'https') {
    // Currently no support for HTTPS over flash
    this.errorHandler("FLASH_TLS_ERR");
    return;
  }

  FlashTransport.bridge.init(this.id, url);
};


FlashSocket.prototype.send = function(data) {
  var id = this.id;
  nextTick(function () {
    FlashTransport.bridge.send(id, data);
  });
};


FlashSocket.prototype.close = function(code, reason) {
  if (!this.id) {
    return;
  }

  if (this.connected) {
    FlashTransport.bridge.close(this.id);
    this.connected = false;
  }

  if (this.initTimer) {
    clearTimeout(this.initTimer);
    this.initTimer = null;
  }

  delete FlashTransport.sockets[this.id];

  this.id = null;

  if (!this.onclose) {
    return;
  }

  this.onclose({
    type: "close",
    code: code || STATUS_NO_STATUS_RCVD,
    reason: reason || "FLASH_UNKNOWN_ERR"
  });

};


function flashSocketInit(url) {
  var socket;

  socket = new FlashSocket(url);

  FlashTransport.sockets[socket.id] = socket;

  if (!FlashTransport.bridge) {
    FlashTransport.embed();
  }

  if (FlashTransport.ready) {
    socket.init();
  }

  return socket;
}


if ((typeof DISABLE_FLASH == "undefined" || DISABLE_FLASH == false) &&
     hasFlashSupport()) {
  AVAILABLE_TRANSPORTS["flash"] = flashSocketInit;
  DEFAULT_TRANSPORT = DEFAULT_TRANSPORT || "flash";
}

var CometTransport = {

  inititalized: false,

  sockets: {},
  socketCount: 0,

  idprefix: "__" + OBJECT_NAME.toLowerCase() + "__",

  idsuffix: "__bridge__",

  origin: global.location.origin || (function() {
    var l = global.location;
    return l.protocol == "file:" ?
            "file://" :
            l.protocol + "://" + l.hostname;
  }()),

  init: function() {
    if ("attachEvent" in global) {
      global.attachEvent("onmessage", CometTransport.messageHandler);
    } else {
      global.addEventListener("message", CometTransport.messageHandler, false);
    }
    CometTransport.inititalized = true;
  },

  destroy: function() {
    if ("detachEvent" in global) {
      global.detachEvent("onmessage", CometTransport.messageHandler);
    } else {
      global.removeEventListener("message", CometTransport.messageHandler, false);
    }
    CometTransport.inititalized = false;
  },

  // Global message handler for all incomming
  // messages. We filter out the underlying FlashSocket
  // by checking the origin.
  messageHandler: function(event) {
    var socket;
    var data;
    var id;
    var op;

    if (event.source == global ||
        typeof event.data != "string" ||
        event.data.length < 8) {
      return;
    }

    id = event.data.substr(0, 8);

    if (!(socket = CometTransport.sockets[id]) ||
        !socket.messageHandler) {
      return;
    }

    op = event.data.charCodeAt(8);
    data = event.data.length > 8 ? event.data.substr(9) : null;

    switch (op) {

      // Handshake
      case 0x01: return socket.openHandler();

      // Error
      case 0x02: return socket.errorHandler(data || "COMET_UNKNOWN_ERR");

      // Message
      case 0x03: return socket.messageHandler(data);

      default: return socket.errorHandler("COMET_ILLGEALOP_ERR");
    }
  }

};


function CometSocket(url) {
  var self = this;
  var elemid;
  var urlobj;
  var port;
  var src;
  var body;

  this.id = uniqueId(true);
  this.url = url;
  this.connected = false;
  this.bridge = null;

  elemid = CometTransport.idprefix + this.id + CometTransport.idsuffix;

  this.elem = document.createElement('iframe');
  this.elem.setAttribute("id", elemid);

  this.elem.style.width = "0px";
  this.elem.style.height = "0px";
  this.elem.style.visibility = "hidden";

  urlobj = parseUri(this.url);

  port = (urlobj.port?':' + urlobj.port:'');
  src = urlobj.protocol + "://" + urlobj.host + port + COMET_PATH;
  src = src + "?origin=" + CometTransport.origin;

  this.elem.src = src;

  function onload() {
    var b = document.getElementById(elemid);
    self.bridge = b.contentWindow;
    self.bridge.postMessage(String(self.id), "*");
  }

  if ('addEventListener' in this.elem) {
      this.elem.addEventListener("load", onload, false);
  } else if ('attachEvent' in this.elem) {
      this.elem.attachEvent("onload", onload);
  } else {
      this.elem.onload = onload;
  }

  body = document.getElementsByTagName('body')[0];
  body.appendChild(this.elem);

  this.initTimer = setTimeout(function () {
    self.errorHandler("COMET_INIT_TIMEOUT_ERR");
  }, 10000);
}

FlashSocket.prototype.bufferedAmount = 0;

CometSocket.prototype.fallbackTransport = null;

CometSocket.prototype.onmessage = sockMessageUtfImpl;
CometSocket.prototype.createFrame = createFrameUtf;
CometSocket.prototype.openHandler = bridgeOpenHandler;
CometSocket.prototype.closeHandler = bridgeCloseHandler;
CometSocket.prototype.errorHandler = bridgeErrorHandler;
CometSocket.prototype.messageHandler = bridgeMessageHandler;


CometSocket.prototype.send = function(data) {
  this.bridge.postMessage("\x03" + data, "*");
};


CometSocket.prototype.close = function(code, reason) {
  var bridge;
  var elem;

  if (!this.id) {
    return;
  }

  delete CometTransport.sockets[this.id];

  this.id = null;

  CometTransport.socketCount--;

  if (CometTransport.socketCount == 0) {
    CometTransport.destroy();
  }

  if (this.initTimer) {
    clearTimeout(this.initTimer);
    this.initTimer = null;
  }

  if ((bridge = this.bridge)) {
    this.connected = false;
    this.bridge = null;
    nextTick(function() {
      try {
        bridge.postMessage("\x02", "*");
      } catch (err) {
      }
    });
  }

  if ((elem = this.elem)) {
    this.elem = null;
    elem.onload = null;
    setTimeout(function () {
      var body = document.getElementsByTagName('body')[0];
      try { body.removeChild(elem); } catch (err) { }
    }, 1);
  }

  if (!this.onclose) {
    return;
  }

  this.onclose({
    type: "close",
    code: code || STATUS_NO_STATUS_RCVD,
    reason: reason || "COMET_UNKNOWN_ERR"
  });
};


function cometSocketInit(url) {
  var socket;

  socket = new CometSocket(url);

  CometTransport.sockets[socket.id] = socket;
  CometTransport.socketCount++;

  if (!CometTransport.inititalized) {
    CometTransport.init();
  }

  return socket;
}


if ((typeof DISABLE_COMET == "undefined" || DISABLE_COMET == false) &&
     typeof global.postMessage != "undefined") {
  AVAILABLE_TRANSPORTS["comet"] = cometSocketInit;
  DEFAULT_TRANSPORT = DEFAULT_TRANSPORT || "comet";
}

var exports = EXPORTS == 'global' ? Channel : {};

exports.VERSION = VERSION;
exports.SUPPORTED = DEFAULT_TRANSPORT !== null;
exports.WEBSOCKET = "websocket" in AVAILABLE_TRANSPORTS;
exports.FLASH = "flash" in AVAILABLE_TRANSPORTS;
exports.COMET = "comet" in AVAILABLE_TRANSPORTS;
exports.MAXSIZE = PAYLOAD_MAX_SIZE;
exports.sizeOf = getsize;

if (EXPORTS !== "global") {
  exports.Channel = Channel;
}

switch (EXPORTS) {

  case "amd":
  define([], function() {
    return exports;
  });
  break;

  case "common":
  module.exports = exports;
  break;

  default:
  if (OBJECT_NAME in global) {
    throw new Error("Target name already taken, or is library already loaded");
  }
  global[OBJECT_NAME] = exports;
  break;
}


})(this);